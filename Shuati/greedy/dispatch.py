# 区间调度问题：有n项工作，每项工作分别在si时间开始，在ti时间结束，目标是参与尽可能多的工作
def dispatch(n: int, s: list, t: list) -> int:
	"""
	贪心算法出现了四种情况
	1. 在可选的工作中，每次都选取开始时间最早的工作。有反例，排除
	2. 在可选的工作中，每次都选取结束时间最早的工作
	3. 在可选的工作中，每次都选取用时最短的工作，有反例，排除
	4. 在可选的工作中，每次都选取与最少可选工作有重叠的工作，有反例，排除
	选取第二种方式
	"""
	# 根据结束时间升序排序，同时将开始时间和结束时间绑定在一起
	tasks = sorted(list(zip(s, t)), key=lambda x: x[1])
	# 分别初始化项目数量和结束时间
	count, time = 0, 0
	# 对于每个项目，如果当前时间小于任务开始时间，则加入任务，同时更新时间为项目结束时间
	for i in range(n):
		if time < tasks[i][0]:
			time = tasks[i][1]
			count += 1

	return count


if __name__ == '__main__':
	print(dispatch(5, [1, 2, 4, 6, 8], [3, 5, 7, 9, 10]))
